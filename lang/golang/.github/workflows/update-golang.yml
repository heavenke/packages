name: Update Golang Version

on:
  schedule:
    # 每天UTC时间00:00检查更新 (北京时间08:00)
    - cron: '0 0 * * *'
  workflow_dispatch:
    # 允许手动触发
    inputs:
      version:
        description: 'Go version to update to (e.g., 1.24.6)'
        required: false
        type: string
      target_branch:
        description: 'Target branch to update (leave empty to update all branches)'
        required: false
        type: string

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        branch: [23.x, 24.x, 25.x]
      fail-fast: false
    
    steps:
    - name: Skip if target branch specified and doesn't match
      if: github.event.inputs.target_branch != '' && github.event.inputs.target_branch != matrix.branch
      run: |
        echo "Skipping branch ${{ matrix.branch }} as target branch is ${{ github.event.inputs.target_branch }}"
        exit 0

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ matrix.branch }}
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests beautifulsoup4 lxml

    - name: Check for new Go version
      id: check_version
      run: |
        python3 << 'EOF'
        import re
        import requests
        import sys
        from bs4 import BeautifulSoup
        import hashlib
        import os
        import subprocess

        def get_current_version():
            """从Makefile读取当前版本"""
            try:
                with open('golang/Makefile', 'r') as f:
                    content = f.read()
                
                major_minor_match = re.search(r'GO_VERSION_MAJOR_MINOR:=(.+)', content)
                patch_match = re.search(r'GO_VERSION_PATCH:=(.+)', content)
                
                if major_minor_match:
                    major_minor = major_minor_match.group(1).strip()
                    # 处理patch可能为空的情况
                    patch = ""
                    if patch_match:
                        patch_value = patch_match.group(1).strip()
                        # 只有当patch不为空时才使用
                        if patch_value:
                            patch = patch_value
                    
                    print(f"Found major_minor: '{major_minor}', patch: '{patch}'")
                    
                    # 处理预发布版本格式（RC/beta版本的完整版本号在major_minor中）
                    if 'rc' in major_minor.lower() or 'beta' in major_minor.lower():
                        # 预发布版本：1.25rc2, 1.25beta1 等
                        return major_minor
                    elif patch:
                        # 稳定版本：1.24.5 等
                        return f"{major_minor}.{patch}"
                    else:
                        # 基础版本：1.25 等（没有patch）
                        return major_minor
                else:
                    print("Could not find GO_VERSION_MAJOR_MINOR in Makefile")
                    return None
            except FileNotFoundError:
                print("golang/Makefile not found")
                return None
            except Exception as e:
                print(f"Error reading Makefile: {e}")
                return None

        def get_branch_major_minor():
            """从当前分支名获取目标大版本号"""
            try:
                # 获取当前分支名
                result = subprocess.run(['git', 'branch', '--show-current'], 
                                      capture_output=True, text=True, check=True)
                branch_name = result.stdout.strip()
                print(f"Current branch: {branch_name}")
                
                # 从分支名提取版本号，如 24.x -> 1.24
                if branch_name.endswith('.x'):
                    minor_version = branch_name[:-2]  # 移除 .x
                    major_minor = f"1.{minor_version}"
                    print(f"Target major.minor version: {major_minor}")
                    return major_minor
                else:
                    print(f"Branch name {branch_name} doesn't follow expected pattern (XX.x)")
                    return None
            except Exception as e:
                print(f"Error getting branch info: {e}")
                return None

        def get_latest_patch_version(target_major_minor):
            """从pkg.go.dev获取指定大版本的最新patch版本"""
            try:
                print(f"Looking for latest patch version for {target_major_minor}")
                response = requests.get('https://pkg.go.dev/std?tab=versions', timeout=30)
                response.raise_for_status()
                soup = BeautifulSoup(response.content, 'html.parser')
                
                # 检查是否为1.25版本（允许beta/rc）
                allow_prerelease = target_major_minor == "1.25"
                if allow_prerelease:
                    print("1.25 branch detected - allowing beta/rc versions")
                
                # 查找指定大版本的所有版本
                if allow_prerelease:
                    # 1.25版本：匹配 go1.25beta1, go1.25rc2, go1.25, go1.25.1 等
                    version_pattern = re.compile(rf'/std@go{re.escape(target_major_minor)}(?:(?:beta|rc)\d+|\.\d+)?$')
                else:
                    # 其他版本：只匹配稳定版本
                    version_pattern = re.compile(rf'/std@go{re.escape(target_major_minor)}\.\d+$')
                
                version_links = soup.find_all('a', href=version_pattern)
                
                latest_patch = 0
                latest_version = None
                latest_prerelease_priority = 999  # 0=stable, 1=rc, 999=beta
                latest_prerelease_num = 0
                
                for link in version_links:
                    href = link.get('href', '')
                    
                    if allow_prerelease:
                        # 1.25版本：匹配 go1.25beta1, go1.25rc2, go1.25, go1.25.1
                        version_match = re.search(rf'/std@go({re.escape(target_major_minor)}(?:(beta|rc)(\d+)|\.(\d+)|$))', href)
                        if version_match:
                            full_version = version_match.group(1)
                            prerelease_type = version_match.group(2)  # beta, rc, or None
                            prerelease_num = int(version_match.group(3) or "0")  # 预发布版本号
                            patch_version = int(version_match.group(4) or "0")  # patch版本号
                            
                            # 计算优先级：stable(0) > rc(1) > beta(999)
                            if prerelease_type is None:
                                prerelease_priority = 0  # stable
                                effective_patch = patch_version
                            elif prerelease_type == 'rc':
                                prerelease_priority = 1  # rc
                                effective_patch = 0  # rc versions are for base version
                            elif prerelease_type == 'beta':
                                prerelease_priority = 999  # beta
                                effective_patch = 0  # beta versions are for base version
                            else:
                                continue
                            
                            # 比较版本：先比较patch版本，再比较预发布优先级，最后比较预发布版本号
                            is_newer = False
                            if effective_patch > latest_patch:
                                is_newer = True
                            elif effective_patch == latest_patch:
                                if prerelease_priority < latest_prerelease_priority:
                                    is_newer = True
                                elif prerelease_priority == latest_prerelease_priority:
                                    if prerelease_type and prerelease_num > latest_prerelease_num:
                                        is_newer = True
                                    elif not prerelease_type and not latest_version.endswith(('beta', 'rc')):
                                        # Both are stable versions, already handled by patch comparison
                                        pass
                            
                            if is_newer:
                                latest_patch = effective_patch
                                latest_version = full_version
                                latest_prerelease_priority = prerelease_priority
                                latest_prerelease_num = prerelease_num
                                print(f"Found version: {full_version}")
                    else:
                        # 其他版本：只匹配稳定版本
                        version_match = re.search(rf'/std@go({re.escape(target_major_minor)}\.(\d+))$', href)
                        if version_match:
                            full_version = version_match.group(1)
                            patch_version = int(version_match.group(2))
                            
                            # 确保不包含rc、beta等标识
                            if not any(x in full_version.lower() for x in ['beta', 'rc', 'alpha', 'dev']):
                                if patch_version > latest_patch:
                                    latest_patch = patch_version
                                    latest_version = full_version
                                    print(f"Found patch version: {full_version}")
                
                if latest_version:
                    print(f"Latest version for {target_major_minor}: {latest_version}")
                    return latest_version
                
                # 如果上面的方法失败，尝试查找版本文本
                print("Trying alternative method to find versions...")
                if allow_prerelease:
                    version_elements = soup.find_all(text=re.compile(rf'go{re.escape(target_major_minor)}(?:(?:beta|rc)\d+|\.\d+)?$'))
                else:
                    version_elements = soup.find_all(text=re.compile(rf'go{re.escape(target_major_minor)}\.\d+$'))
                
                for element in version_elements:
                    if allow_prerelease:
                        version_match = re.search(rf'go({re.escape(target_major_minor)}(?:(beta|rc)(\d+)|\.(\d+)|$))', element.strip())
                        if version_match:
                            full_version = version_match.group(1)
                            prerelease_type = version_match.group(2)
                            prerelease_num = int(version_match.group(3) or "0")
                            patch_version = int(version_match.group(4) or "0")
                            
                            # 使用相同的比较逻辑
                            if prerelease_type is None:
                                prerelease_priority = 0
                                effective_patch = patch_version
                            elif prerelease_type == 'rc':
                                prerelease_priority = 1
                                effective_patch = 0
                            elif prerelease_type == 'beta':
                                prerelease_priority = 999
                                effective_patch = 0
                            else:
                                continue
                            
                            is_newer = False
                            if effective_patch > latest_patch:
                                is_newer = True
                            elif effective_patch == latest_patch:
                                if prerelease_priority < latest_prerelease_priority:
                                    is_newer = True
                                elif prerelease_priority == latest_prerelease_priority and prerelease_type and prerelease_num > latest_prerelease_num:
                                    is_newer = True
                            
                            if is_newer:
                                latest_patch = effective_patch
                                latest_version = full_version
                                latest_prerelease_priority = prerelease_priority
                                latest_prerelease_num = prerelease_num
                                print(f"Found version from text: {full_version}")
                    else:
                        version_match = re.search(rf'go({re.escape(target_major_minor)}\.(\d+))$', element.strip())
                        if version_match:
                            full_version = version_match.group(1)
                            patch_version = int(version_match.group(2))
                            
                            if not any(x in full_version.lower() for x in ['beta', 'rc', 'alpha', 'dev']):
                                if patch_version > latest_patch:
                                    latest_patch = patch_version
                                    latest_version = full_version
                                    print(f"Found patch version from text: {full_version}")
                
                if latest_version:
                    print(f"Latest version for {target_major_minor}: {latest_version}")
                    return latest_version
                else:
                    print(f"No versions found for {target_major_minor}")
                    return None
                    
            except Exception as e:
                print(f"Error fetching latest patch version: {e}")
                return None

        def get_source_hash(version):
            """获取源码包的SHA256哈希"""
            try:
                url = f"https://dl.google.com/go/go{version}.src.tar.gz"
                response = requests.get(url, timeout=60)
                response.raise_for_status()
                
                sha256_hash = hashlib.sha256()
                for chunk in response.iter_content(chunk_size=8192):
                    sha256_hash.update(chunk)
                
                return sha256_hash.hexdigest()
            except Exception as e:
                print(f"Error downloading source: {e}")
                return None

        # 获取手动输入的版本或检查最新版本
        manual_version = "${{ github.event.inputs.version }}"
        if manual_version:
            target_version = manual_version
            print(f"Using manual version: {target_version}")
        else:
            # 获取当前分支对应的大版本号
            target_major_minor = get_branch_major_minor()
            if not target_major_minor:
                print("Failed to determine target major.minor version from branch")
                sys.exit(1)
            
            # 获取该大版本的最新patch版本
            target_version = get_latest_patch_version(target_major_minor)
            if not target_version:
                print(f"Failed to get latest patch version for {target_major_minor}")
                sys.exit(1)
            print(f"Latest patch version found: {target_version}")

        current_version = get_current_version()
        print(f"Current version: {current_version}")

        if current_version == target_version:
            print("Already up to date")
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write(f"needs_update=false\n")
                f.write(f"current_version={current_version}\n")
                f.write(f"target_version={target_version}\n")
            sys.exit(0)

        # 获取新版本的哈希
        print(f"Getting hash for version {target_version}...")
        new_hash = get_source_hash(target_version)
        if not new_hash:
            print("Failed to get source hash")
            sys.exit(1)

        print(f"New hash: {new_hash}")

        # 解析版本号用于Makefile更新
        if 'rc' in target_version or 'beta' in target_version:
            # 预发布版本：1.25rc2 -> major_minor=1.25rc2, patch=""
            major_minor = target_version
            patch = ""
        else:
            # 稳定版本：1.25.1 -> major_minor=1.25, patch=1
            version_parts = target_version.split('.')
            if len(version_parts) != 3:
                print(f"Invalid version format: {target_version}")
                sys.exit(1)
            major_minor = f"{version_parts[0]}.{version_parts[1]}"
            patch = version_parts[2]

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"needs_update=true\n")
            f.write(f"current_version={current_version}\n")
            f.write(f"target_version={target_version}\n")
            f.write(f"major_minor={major_minor}\n")
            f.write(f"patch={patch}\n")
            f.write(f"new_hash={new_hash}\n")

        EOF

    - name: Update Makefile
      if: steps.check_version.outputs.needs_update == 'true'
      run: |
        # 备份原文件
        cp golang/Makefile golang/Makefile.bak
        
        # 更新版本号和哈希
        sed -i "s/GO_VERSION_MAJOR_MINOR:=.*/GO_VERSION_MAJOR_MINOR:=${{ steps.check_version.outputs.major_minor }}/" golang/Makefile
        sed -i "s/GO_VERSION_PATCH:=.*/GO_VERSION_PATCH:=${{ steps.check_version.outputs.patch }}/" golang/Makefile
        sed -i "s/PKG_HASH:=.*/PKG_HASH:=${{ steps.check_version.outputs.new_hash }}/" golang/Makefile
        
        # 显示变更
        echo "Changes made to Makefile:"
        diff -u golang/Makefile.bak golang/Makefile || true
        rm golang/Makefile.bak

    - name: Verify changes
      if: steps.check_version.outputs.needs_update == 'true'
      run: |
        echo "Verifying Makefile changes..."
        grep "GO_VERSION_MAJOR_MINOR:=${{ steps.check_version.outputs.major_minor }}" golang/Makefile
        grep "GO_VERSION_PATCH:=${{ steps.check_version.outputs.patch }}" golang/Makefile
        grep "PKG_HASH:=${{ steps.check_version.outputs.new_hash }}" golang/Makefile
        echo "Verification successful!"

    - name: Commit and push changes
      if: steps.check_version.outputs.needs_update == 'true'
      run: |
        # 配置Git用户信息
        git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # 添加更改的文件
        git add golang/Makefile
        
        # 提交更改
        git commit -m "golang: bump to ${{ steps.check_version.outputs.target_version }}

        Updates Golang from ${{ steps.check_version.outputs.current_version }} to ${{ steps.check_version.outputs.target_version }}.

        Changes:
        - Updated GO_VERSION_MAJOR_MINOR to ${{ steps.check_version.outputs.major_minor }}
        - Updated GO_VERSION_PATCH to ${{ steps.check_version.outputs.patch }}
        - Updated PKG_HASH to ${{ steps.check_version.outputs.new_hash }}

        This update was automatically generated by GitHub Actions."
        
        # 推送到当前分支
        git push

    - name: Summary
      run: |
        if [ "${{ steps.check_version.outputs.needs_update }}" == "true" ]; then
          echo "✅ [${{ matrix.branch }}] Successfully updated Golang from ${{ steps.check_version.outputs.current_version }} to ${{ steps.check_version.outputs.target_version }}"
        else
          echo "ℹ️ [${{ matrix.branch }}] Golang is already up to date at version ${{ steps.check_version.outputs.current_version }}"
        fi